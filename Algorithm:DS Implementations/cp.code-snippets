{
	"Generic <T> Class": {
		"prefix": "pointsegtree",
		"body": [
		  "template <typename T>",
		  "struct segtree",
		  "{",
		  "    T val, none;",
		  "    int l, r, mid;",
		  "    segtree<T> *left, *right;",
		  "",
		  "    T comb(T& l, T& r){",
		  "        return min(l, r); //modify",
		  "    }",
		  "",
		  "    segtree(int gL, int gR, vector<T>& nums, T non){ ",
		  "        l = gL, r = gR, mid = (l+r)/2, none = non;",
		  "        if (l == r){",
		  "            val = nums[l];",
		  "        }else{",
		  "            left = new segtree<T>(l, mid, nums, none), right = new segtree<T>(mid + 1, r, nums, none);",
		  "            val = comb(left->val, right->val);",
		  "        }",
		  "    }",
		  "",
		  "    T query(int ql, int qr){",
		  "        if (ql > r || qr < l) return none;",
		  "        if (ql == l && qr == r) return val;",
		  "        T a = left->query(ql, min(qr, mid)), b = right->query(max(ql, mid + 1), qr);",
		  "        return comb(a, b);",
		  "    }",
		  "",
		  "    void update(int idx, T set){",
		  "        if (l == r){",
		  "            val = set;",
		  "        }else{",
		  "            if (idx <= (l + r) / 2) left->update(idx, set);",
		  "            else { right->update(idx, set); }",
		  "            val = comb(left->val, right->val);",
		  "        }",
		  "   }",
		  "};"
		],
		"description": "Generic <T> Class"
	  },
	"Union-Find with vector": {
		"prefix": "DSU",
		"body": [
		  "struct DSU{",
		  "    vector<int> par, sz;",
		  "    DSU(int n){",
		  "        par.reserve(n); sz.reserve(n);",
		  "        for(int i = 0; i<n; i++) {",
		  "            par.pb(i); sz.pb(1);",
		  "        }",
		  "    }",
		  "",
		  "    int root(int u){",
		  "        return par[u] == u ? u : par[u] = root(par[u]);",
		  "    }",
		  "",
		  "    void unite(int u, int v){",
		  "        int ru = root(u); int rv = root(v);",
		  "        if(ru == rv) return;",
		  "        if(sz[rv] > sz[ru]) swap(ru, rv);",
		  "        sz[ru] += sz[rv];",
		  "        par[rv] = ru;",
		  "    }",
		  "",
		  "};"
		],
		"description": "Union-Find with vector"
	},
	  
	"Edges are pair<long long, int>, returns long long vector": {
		"prefix": "Dijkstra",
		"body": [
			"//NOTE: Edges are pair<ll, int>",
			"vector<ll> dijkstra(int n, vector<pii> adj[], int u){",
			"    vector<ll> ret(n); ",
			"    fill(ret.begin(), ret.end(), -1);",
			"    priority_queue<pii, vector<pii>, greater<pii>> pq;",
			"    pq.push(pii(0, u));",
			"    while(!pq.empty()){",
			"        pii cur = pq.top(); pq.pop();",
			"        if(ret[cur.s]!=-1) {",
			"            continue;",
			"        }",
			"        ret[cur.s] = cur.f;",
			"        for(auto n : adj[cur.s]){",
			"            if(ret[cur.s]!=-1) {",
			"                pq.push(pii(cur.f+n.f, n.s));",
			"            }",
			"        }",
			"    }",
			"    return ret;",
			"}"
		],
		"description": "Edges are pair<long long, int>, returns long long array"
	},
	  
	"<4 to exclude diagonals": {
		"prefix": "dirs",
		"body": [
		  "int rDir[8] = {1, -1, 0, 0, -1, 1, -1, 1};",
		  "int cDir[8] = {0, 0, 1, -1, 1, 1, -1, -1};"
		],
		"description": "<4 to exclude diagonals"
	  },
	  "BIT": {
		"prefix": "BIT",
		"body": [
		  "template <typename T>",
		  "struct BIT {",
		  "    vector<T> bit;",
		  "    int n;",
		  "",
		  "    BIT(int N) {",
		  "        n = N + 1;",
		  "        bit.resize(n);",
		  "    }",
		  "",
		  "    BIT(int nums[], int N){",
		  "        n = N+1;",
		  "        bit.resize(n);",
		  "        for (int i = 1; i < n; i++) {",
		  "            bit[i] += nums[i - 1]; //update node",
		  "            if (i + (i & -i) < n) {",
		  "                bit[i + (i & -i)] += bit[i]; //update parent",
		  "            }",
		  "        }",
		  "    }",
		  "    ",
		  "    T sum(int l, int r) {",
		  "        return sum(r) - sum(l - 1);",
		  "    }",
		  "",
		  "    T sum(int r) {",
		  "        r++;",
		  "        T ret = 0;",
		  "        while (r > 0) {",
		  "            ret += bit[r];",
		  "            r -= r & -r;",
		  "        }",
		  "        return ret;",
		  "    }",
		  "",
		  "    //updates # at pos nums[idx]",
		  "    //does not reset nums[idx], but updates it (+/-)",
		  "    void update(int idx, T v) {",
		  "        idx++;",
		  "        while (idx < n) {",
		  "            bit[idx] += v;",
		  "            idx += idx & -idx;",
		  "        }",
		  "    }",
		  "};"
		],
		"description": "BIT"
	  },
	  "file input-output in c++, ok to use regular io after": {
		"prefix": "setio",
		"body": [
		  "void setIO(string s) { // the argument is the filename without the extension",
		  "	freopen((s+\".in\").c_str(),\"r\",stdin);",
		  "	freopen((s+\".out\").c_str(),\"w\",stdout);",
		  "}"
		],
		"description": "file input-output in c++, ok to use regular io after"
	  },
	  "Supports N < 8,000,000; Default type: int": {
		"prefix": "sparsetable",
		"body": [
		  "struct sTable",
		  "{",
		  "    vector<int> table[25];",
		  "    sTable(int num[], int N)",
		  "    {",
		  "        int maxFit = maxPow(N);",
		  "        assert(maxFit < 25);",
		  "        table[0].reserve(N);",
		  "        for(int i = 0; i<N; i++) table[0][i] = num[i];",
		  "",
		  "        for (int i = 1; i < maxFit; i++)",
		  "        {",
		  "            table[i].reserve(N);",
		  "            for (int j = 0; j + (1 << i) - 1 < N; j++)",
		  "            {",
		  "                table[i][j] = min(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    int get(int l, int r)",
		  "    {",
		  "        int max = maxPow(r - l + 1) - 1;",
		  "        return min(table[max][l], table[max][r - (1 << max) + 1]);",
		  "    }",
		  "",
		  "    //a^b, returns b+1",
		  "    int maxPow(int num)",
		  "    {",
		  "        int ret = 0;",
		  "        while (num > 0)",
		  "        {",
		  "            num >>= 1;",
		  "            ret++;",
		  "        }",
		  "        return ret;",
		  "    }",
		  "};"
		],
		"description": "Supports N < 8,000,000; Default type: int"
	  },
	  "Way slower than BIT inversion counting": {
		"prefix": "find_inversions",
		"body": [
		  "//pretty slow compared to BIT",
		  "pair<ll, vector<int>> find_inversions(int nums[], int l, int r){ //all nums[i] in nums is distinct",
		  "    pair<ll, vector<int>> ret;",
		  "    if(l == r){",
		  "        ret.s.pb(nums[l]);",
		  "    }else{",
		  "        pair<ll, vector<int>> left = find_inversions(nums, l, (l+r)/2), right = find_inversions(nums, (l+r)/2+1, r);",
		  "        ret.f = left.f + right.f;",
		  "        int p1 = 0, p2 = 0;",
		  "        while(p1 < left.s.size() || p2 < right.s.size()){",
		  "            while(p1 < left.s.size() && (p2 == right.s.size() || left.s[p1] < right.s[p2])){",
		  "                ret.s.pb(left.s[p1]); p1++; ret.f += p2;",
		  "            }",
		  "            while(p2 < right.s.size() && (p1 == left.s.size() || left.s[p1] > right.s[p2])){",
		  "                ret.s.pb(right.s[p2]); p2++;",
		  "            }",
		  "        }",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "Way slower than BIT inversion counting"
	  },
	  "2e5, everything included": {
		"prefix": "lca",
		"body": [
		  "const int maxn = 2e5+7; const int maxlog = 19;",
		  "int dep[maxn], lift[maxlog][maxn];",
		  "",
		  "vector<int> adj[maxn];",
		  "",
		  "void init(int u, int p = 0, int h = 0){",
		  "    dep[u] = h; lift[0][u] = p;",
		  "    for(int i = 1; i<maxlog; i++){",
		  "        lift[i][u] = lift[i-1][lift[i-1][u]];",
		  "    }",
		  "    for(int n : adj[u]){",
		  "        if(p != n) init(n, u, h+1);",
		  "    }",
		  "}",
		  "",
		  "int jump(int u, int k){ //view k in binary",
		  "    for(int i = 0; i<maxlog; i++){",
		  "        if((k >> i) & 1){",
		  "            u = lift[i][u];",
		  "        }",
		  "    }",
		  "    return u;",
		  "}",
		  "",
		  "int lca(int u, int v){",
		  "    if(dep[u] > dep[v]) swap(u, v);",
		  "    v = jump(v, dep[v] - dep[u]);",
		  "    assert(dep[u] == dep[v]);",
		  "    if(u == v) {",
		  "        return u;",
		  "    }",
		  "    for(int i = maxlog-1; i>=0; i--){ //jump pows strictly decrease",
		  "        if(lift[i][u] != lift[i][v]){",
		  "            u = lift[i][u]; v = lift[i][v];",
		  "        }",
		  "    }",
		  "    return lift[0][u];",
		  "}"
		],
		"description": "2e5, everything included"
	  },
	  "Sum || Lazy purely for propagation, updates occur immediately": {
		"prefix": "lazysegtree",
		"body": [
		  "template <typename T>",
		  "struct segtree",
		  "{",
		  "    T none, lazynone, val, lazy; //comb(a, none) = a",
		  "    int gL, gR, mid;",
		  "    segtree<T> *left, *right;",
		  "",
		  "    T comb(T &l, T &r)",
		  "    {",
		  "        return l + r; //modify",
		  "    }",
		  "",
		  "    //mod lazy, upd val",
		  "    //In this code, lazy represents the value only to be propagated(this->value already updated)",
		  "    void compose(segtree<T> *tree, T v)",
		  "    {",
		  "        tree->lazy += v;",
		  "        tree->val += (tree->gR - tree->gL + 1) * v;",
		  "        // cout << tree -> gL << \" \" << tree -> gR << \" \" << tree -> val << \" \" << tree -> lazy << endl;",
		  "    }",
		  "    ",
		  "    void push()",
		  "    {",
		  "        if (gL != gR)",
		  "        {",
		  "            compose(left,lazy);",
		  "            compose(right,lazy);",
		  "        }",
		  "        lazy = lazynone;",
		  "    }",
		  "",
		  "    segtree(int l, int r, T arr[], T non, T lazynon)",
		  "    { //modify arr type",
		  "        none = non, lazy = lazynone = lazynon;",
		  "        gL = l, gR = r, mid = (gL + gR) / 2;",
		  "        if (l == r)",
		  "        {",
		  "            val = arr[l];",
		  "        }",
		  "        else",
		  "        {",
		  "            left = new segtree<T>(l, mid, arr, non, lazynon);",
		  "            right = new segtree<T>(mid + 1, r, arr, non, lazynon);",
		  "            val = comb(",
		  "                left->val, right->val);",
		  "        }",
		  "    }",
		  "",
		  "    T query(int l, int r)",
		  "    {",
		  "",
		  "        if (gL > r || gR < l)",
		  "        {",
		  "            return none;",
		  "        }",
		  "        ",
		  "        if (gL == l && gR == r)",
		  "        {",
		  "            return val;",
		  "        }",
		  "        push();",
		  "        T a = left->query(l, min(r, mid));",
		  "        T b = right->query(max(l, mid + 1), r);",
		  "        return comb(a, b);",
		  "    }",
		  "",
		  "    void update(int l, int r, T updlazy)",
		  "    {",
		  "        if(gL > r || gR < l){",
		  "            return;",
		  "        }",
		  "        ",
		  "        if(gL == l && gR == r){",
		  "            compose(this, updlazy);",
		  "        }else{",
		  "            push();",
		  "            left -> update(l, min(r, mid), updlazy);",
		  "            right -> update(max(l, mid+1), r, updlazy);",
		  "            val = comb(left->val, right->val);",
		  "        }",
		  "    }",
		  "};"
		],
		"description": "Sum || Lazy purely for propagation, updates occur immediately"
	  },
	  "Inv of a: a^(mod-2)": {
		"prefix": "rec_binpow",
		"body": [
		  "int binpow(ll base, ll pow)",
		  "{",
		  "    if (pow == 0) return 1;",
		  "    ll half = binpow(base, pow / 2);",
		  "    ll ret = (half * half) % mod;",
		  "    if (pow % 2 == 1) ret *= base;",
		  "    return ret%mod;",
		  "}"
		],
		"description": "Inv of a: a^(mod-2)"
	  },
	  "Modify Mod if needed": {
		"prefix": "modint",
		"body": [
		  "template<int MOD>",
		  "struct ModInt {",
		  "  unsigned x;",
		  "  ModInt() : x(0) { }",
		  "  ModInt(signed sig) : x(sig) {  }",
		  "  ModInt(signed long long sig) : x(sig%MOD) { }",
		  "  int get() const { return (int)x; }",
		  "  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }",
		  " ",
		  "  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }",
		  "  ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }",
		  "  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }",
		  "  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MOD - 2); }",
		  " ",
		  "  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }",
		  "  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }",
		  "  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }",
		  "  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }",
		  "  bool operator<(ModInt that) const { return x < that.x; }",
		  "  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }",
		  "};",
		  "typedef ModInt<1000000007> mint;"
		],
		"description": "Modify Mod if needed"
	  },
	  "point update range query segment tree with nodes": {
		"prefix": "nodesgt",
		"body": [
		  "struct node{",
		  "    ll val = 0;",
		  "    int isDummy = 0;",
		  "    node(){}",
		  "    node(ll v){val = v;}",
		  "    //assume current is left",
		  "    node comb(node& other){",
		  "        //no change cur_node or other_node values",
		  "        return node(other.val + val);",
		  "    }",
		  "};",
		  "",
		  "struct segtree",
		  "{",
		  "    node val;",
		  "    int gL, gR, mid;",
		  "    segtree *left, *right;",
		  "",
		  "    segtree(int l, int r, vector<node>& nums)",
		  "    {",
		  "        gL = l; gR = r; mid = (gL+gR)/2;",
		  "        if (l == r)",
		  "        {",
		  "            val = nums[l];",
		  "        }",
		  "        else",
		  "        {",
		  "            ",
		  "            left = new segtree(l, mid, nums), right = new segtree(mid + 1, r, nums);",
		  "            val = left->val.comb(right->val);",
		  "        }",
		  "    }",
		  "",
		  "    node query(int l, int r)",
		  "    {",
		  "",
		  "        if (gL > r || gR < l)",
		  "        {",
		  "            node dummy; dummy.isDummy=1;",
		  "            return dummy;",
		  "        }",
		  "",
		  "        if (gL == l && gR == r)",
		  "        {",
		  "            return val;",
		  "        }",
		  "        node a = left->query(l, min(r, mid)), b = right->query(max(l, mid + 1), r);",
		  "        if(a.isDummy) return b;",
		  "        if(b.isDummy) return a;",
		  "        return a.comb(b);",
		  "    }",
		  "",
		  "    void update(int idx, node& set)",
		  "    {",
		  "        if (gL == gR)",
		  "        {",
		  "            val = set;",
		  "        }",
		  "        else",
		  "        {",
		  "            if (idx <= (gL + gR) / 2)",
		  "            {",
		  "                left->update(idx, set);",
		  "            }",
		  "            else",
		  "            {",
		  "                right->update(idx, set);",
		  "            }",
		  "            val = left->val.comb(right->val);",
		  "        }",
		  "   }",
		  "};"
		],
		"description": "Use isDummy"
	  },
	  "LIS": {
		"prefix": "LongestIncreasingSubsequence",
		"body": [
		  "vector<int> lis(vector<int>& nums, int strict = 1){",
		  "    vector<int> ret;",
		  "    for(int i : nums){",
		  "        auto it = strict ? ",
		  "            lower_bound(ret.begin(), ret.end(), i) : ",
		  "            upper_bound(ret.begin(), ret.end(), i);",
		  "        if(it == ret.end()){",
		  "            ret.pb(i);",
		  "        }else{",
		  "            *it = i;",
		  "        }",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "LIS"
	  },
	  "2 mods, 1 base": {
		"prefix": "DoubleModHash",
		"body": [
		  "struct HashedString{",
		  "    int moda = 1e9+7, modb = 1e9+9;",
		  "    ll base = 9973;",
		  "",
		  "    vector<pii> poly; //a[i] + a[i] * x + a[i] * x^2 + a[i] * x^3 ...",
		  "    vector<pair<ll, ll>> pow;",
		  "    HashedString(int N, string str){",
		  "        poly.resize(N+1); pow.resize(N+1); pow[0].f = pow[0].s = 1;",
		  "        for(int i = 1; i<=N; i++) {",
		  "            pow[i].f = (pow[i-1].f * base)%moda;",
		  "            pow[i].s = (pow[i-1].s * base)%modb;",
		  "        }",
		  "        for(int i = N-1; i>=0; i--){",
		  "            poly[i].f = (poly[i+1].f*base + str[i])%moda;",
		  "            poly[i].s = (poly[i+1].s*base + str[i])%modb;",
		  "        }",
		  "    }",
		  "",
		  "    //inclusive",
		  "    pii get(int l, int r){",
		  "        pii ret;",
		  "        ret.f = (poly[l].f - (poly[r+1].f*(pow[r-l+1].f)%moda) + moda) % moda;",
		  "        ret.s = (poly[l].s - (poly[r+1].s*(pow[r-l+1].s)%modb) + modb) % modb;",
		  "        return ret;",
		  "    }",
		  "};"
		],
		"description": "2 mods, 1 base"
	  },
	  "Inv of a: a^(mod-2)": {
		"prefix": "binpow",
		"body": [
		  "int binpow(ll base, ll pow)",
		  "{",
		  "    ll ret = 1;",
		  "    while(pow > 0){",
		  "        if(pow & 1) ret = (ret * base)%mod;",
		  "        base = (base * base)%mod;",
		  "        pow >>= 1;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "Inv of a: a^(mod-2)"
	  },
	  "Compress state transitions": {
		"prefix": "template_matrix",
		"body": [
		  "const int S = 2; //minimum state size nessesary in DP to get next value",
		  "const int mod = 1e9+7;",
		  "",
		  "ll transition[S][S] = {{0,1},{1,1}}; //How to extend by DP by 1 index",
		  "ll zeroes[S][S];",
		  "",
		  "struct Matrix{",
		  "    ll a[S][S];",
		  "",
		  "    //identity matrix",
		  "    Matrix(){",
		  "        for(int i = 0; i<S; i++) for(int j = 0; j<S; j++) a[i][j] = i == j; ",
		  "    }",
		  "",
		  "    Matrix(ll init[S][S]){",
		  "        for(int i = 0; i<S; i++) for(int j = 0; j<S; j++) a[i][j] = init[i][j];",
		  "    }",
		  "",
		  "    Matrix operator* (Matrix& other){",
		  "        Matrix ret(zeroes);",
		  "        for(int i = 0; i<S; i++){",
		  "            for(int j = 0; j<S; j++){",
		  "                for(int k = 0; k<S; k++){",
		  "                    ret.a[i][k] += (a[i][j] * other.a[j][k]) % mod;",
		  "                    ret.a[i][k] %= mod;",
		  "                }",
		  "            }",
		  "        }",
		  "        return ret;",
		  "    } ",
		  "};",
		  "",
		  "//binpow: matrix^(i+j) = matrix^i * matrix^j",
		  "Matrix binpow(Matrix base, ll pow)",
		  "{",
		  "    Matrix ret;",
		  "    while(pow > 0){",
		  "        if(pow & 1) ret = ret * base;",
		  "        base = base * base;",
		  "        pow >>= 1;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "Compress state transitions"
	  },
	  "!create temp last query! ~ can sort like usual ~ gilbert": {
		"prefix": "mo's_template",
		"body": [
		  "int64_t gilbertOrder(int x, int y, int pow, int rotate) {",
		  "	if (pow == 0) {",
		  "		return 0;",
		  "	}",
		  "	int hpow = 1 << (pow-1);",
		  "	int seg = (x < hpow) ? (",
		  "		(y < hpow) ? 0 : 3",
		  "	) : (",
		  "		(y < hpow) ? 1 : 2",
		  "	);",
		  "	seg = (seg + rotate) & 3;",
		  "	const int rotateDelta[4] = {3, 0, 0, 1};",
		  "	int nx = x & (x ^ hpow), ny = y & (y ^ hpow);",
		  "	int nrot = (rotate + rotateDelta[seg]) & 3;",
		  "	int64_t subSquareSize = int64_t(1) << (2*pow - 2);",
		  "	int64_t ans = seg * subSquareSize;",
		  "	int64_t add = gilbertOrder(nx, ny, pow-1, nrot);",
		  "	ans += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);",
		  "	return ans;",
		  "}",
		  "",
		  "struct Query{",
		  "    int l, r, idx; //inclusive",
		  "    int64_t order;",
		  "    Query(){}",
		  "    Query(int a, int b, int c){",
		  "        l = a, r = b, idx = c; ",
		  "        order = gilbertOrder(l, r, 21, 0);",
		  "    }",
		  "    bool operator<(const Query& other) const {",
		  "        return order < other.order;",
		  "    }",
		  "    // bool operator<(const Query& other) const {",
		  "    //     return l/bket == other.l/bket ? (",
		  "    //         l/bket % 2 ? other.r > r : other.r < r",
		  "    //     ) : l/bket < other.l/bket;",
		  "    // }",
		  "};",
		  "",
		  "void insert(int x){",
		  "}",
		  "",
		  "void remove(int x){",
		  "}",
		  "",
		  "//Query last(0,0,-1); insert(nums[0]);",
		  "void move(Query& from, Query& to){",
		  "    int l = from.l, r = from.r;",
		  "    while(l > to.l) l--, insert(nums[l]);",
		  "    while(r < to.r) r++, insert(nums[r]);",
		  "    while(l < to.l) remove(nums[l]), l++;",
		  "    while(r > to.r) remove(nums[r]), r--;",
		  "}"
		],
		"description": "!create temp last query! ~ can sort like usual ~ gilbert"
	  },
	  "Change bits displayed || with bitset": {
		"prefix": "tobinarystring",
		"body": [
		  "string tobinary(int i){",
		  "    string s = bitset<64>(i).to_string();",
		  "    return s;",
		  "}"
		],
		"description": "Change bits displayed || with bitset"
	  },
	  "Default INT, ordered_set": {
		"prefix": "pbds",
		"body": [
		  "#include <ext/pb_ds/assoc_container.hpp>",
		  "using namespace __gnu_pbds;",
		  "typedef tree<int, null_type, less<int>, ",
		  "    rb_tree_tag,tree_order_statistics_node_update> ordered_set;"
		],
		"description": "ordered_set"
	  },
"For INTEGER, Make maxn": {
	"prefix": "linear_trie",
	"body": [
	  "int trie[33*maxn][2], tIdx = 0;",
	  " ",
	  "void insert(int x) {",
	  "    int node = 0;",
	  "    for (int i=29; i>=0; i--) {",
	  "        int c = x&(1<<i) ? 1 : 0;",
	  "        if (trie[node][c] == -1) trie[node][c] = ++tIdx;",
	  "        node = trie[node][c];",
	  "    }",
	  "}",
	  " ",
	  "//maximize xor",
	  "int query(int x) {",
	  "    int res = 0, node = 0;",
	  "    for (int i=29; i>=0; i--) {",
	  "        int c = x&(1<<i) ? 0 : 1;",
	  "        if (trie[node][c] != -1) {",
	  "            res ^= 1<<i;",
	  "            node = trie[node][c];",
	  "        } else node = trie[node][1^c];",
	  "    }",
	  "    return res;",
	  "}"
	],
	"description": "For INTEGER, Make maxn"
  },
  "INTEGERS -- Maximize XOR - Struct-based": {
	"prefix": "simple_trie",
	"body": [
	  "struct trie{",
	  "    trie* nxt[2] = {0,0};",
	  "",
	  "    void insert(int val, int idx = 29){",
	  "        if(idx < 0) return;",
	  "        int c = (val >> idx)&1;",
	  "        if(nxt[c] == 0) nxt[c] = new trie();",
	  "        nxt[c] -> insert(val, idx-1);",
	  "    }",
	  "",
	  "    //get max xor query",
	  "    int query(int x, int idx = 29){",
	  "        if (idx < 0) return 0;",
	  "        int cur = (x>>idx)&1;",
	  "        if(nxt[cur^1] != 0){ //greedily maximize",
	  "            return nxt[cur^1] -> query(x, --idx);",
	  "        }",
	  "        return nxt[cur] -> query(x, --idx);",
	  "    }",
	  "};"
	],
	"description": "INTEGERS -- Maximize XOR - Struct-based"
  },
  "sorted by pair(val, idx) -> no duplicates": {
	"prefix": "compres",
	"body": [
	  "vector<int> compress(vector<int>& nums){",
	  "    int n = nums.size();",
	  "    vector<int> ret(n);",
	  "    vector<pii> sorted(n);",
	  "    for(int i = 0; i<n; i++) sorted[i] = pii(nums[i], i);",
	  "    sort(sorted.begin(), sorted.end());",
	  "    for(int i = 0; i<n; i++){",
	  "        ret[sorted[i].s] = sorted[i].f;",
	  "    }",
	  "    return ret;",
	  "}"
	],
	"description": "sorted by pair(val, idx) -> no duplicates"
  },
  "⚠️CHANGE MOD⚠️": {
	"prefix": "factorial_template",
	"body": [
	  "const int maxn = 2e5+9; const ll mod = 1e9+7;",
	  "ll dp[maxn];",
	  "",
	  "ll binpow(ll base, ll pow)",
	  "{",
	  "    if (pow == 0) return 1;",
	  "    ll half = binpow(base, pow / 2);",
	  "    ll ret = (half * half) % mod;",
	  "    if (pow % 2 == 1) ret *= base;",
	  "    return ret%mod;",
	  "}",
	  "",
	  "ll choose(ll a, ll b){ //big : small",
	  "    if(a<0||b<0||a<b) return 0;",
	  "    ll ret = dp[a]; ll denom = (dp[a-b]*dp[b])%mod;",
	  "    ret *= binpow(denom, mod-2); ret %= mod;",
	  "    return ret;",
	  "}",
	  "",
	  "int main(){",
	  "    ios_base::sync_with_stdio(false); cin.tie(0);",
	  "    dp[0] = 1;",
	  "    for(int i = 1; i<maxn; i++) dp[i] = (dp[i-1]*i)%mod;",
	  "    cout << choose(1000, 690);",
	  "    return 0;",
	  "}"
	],
	"description": "⚠️CHANGE MOD⚠️"
  },
  "!Change modnum::MOD!, Change size of integer": {
	"prefix": "template_modnum",
	"body": [
	  "struct modnum {",
	  "    // change these if you need another size of integers",
	  "    static inline uint32_t MOD;",
	  "    using u32 = uint32_t;",
	  "    using u64 = uint64_t;",
	  "    using i32 = int32_t;",
	  "    using i64 = int64_t;",
	  "",
	  "    u32 n;",
	  "",
	  "    modnum() : n(0) {}",
	  "    modnum(u64 v) : n(v >= MOD ? v % MOD : v) {}",
	  "    modnum(u32 v) : n(v >= MOD ? v % MOD : v) {}",
	  "    modnum(i64 v) : modnum(v >= 0 ? u64(v) : u64(MOD + v % int(MOD))) {}",
	  "    modnum(i32 v) : modnum(v >= 0 ? u32(v) : u32(MOD + v % int(MOD))) {}",
	  "    explicit operator i32() const { return n; }",
	  "    explicit operator u32() const { return n; }",
	  "    explicit operator bool() const { return n != 0; }",
	  "",
	  "    static u32 fit(u32 x) { return x >= MOD ? x - MOD : x; }",
	  "    static int modinv(u32 x) {",
	  "        int nx = 1, ny = 0;",
	  "        u32 y = MOD;",
	  "        while (x) {",
	  "            auto k = y / x;",
	  "            y = y % x;",
	  "            ny = ny - k * nx;",
	  "            swap(x, y), swap(nx, ny);",
	  "        }",
	  "        return ny < 0 ? MOD + ny : ny;",
	  "    }",
	  "    friend modnum modpow(modnum b, int64_t e) {",
	  "        modnum p = 1;",
	  "        while (e > 0) {",
	  "            if (e & 1)",
	  "                p = p * b;",
	  "            if (e >>= 1)",
	  "                b = b * b;",
	  "        }",
	  "        return p;",
	  "    }",
	  "",
	  "    modnum inv() const { return modinv(n); }",
	  "    modnum operator-() const { return n == 0 ? n : MOD - n; }",
	  "    modnum operator+() const { return *this; }",
	  "    modnum operator++(int) { return n = fit(n + 1), *this - 1; }",
	  "    modnum operator--(int) { return n = fit(MOD + n - 1), *this + 1; }",
	  "    modnum &operator++() { return n = fit(n + 1), *this; }",
	  "    modnum &operator--() { return n = fit(MOD + n - 1), *this; }",
	  "    modnum &operator+=(modnum v) { return n = fit(n + v.n), *this; }",
	  "    modnum &operator-=(modnum v) { return n = fit(MOD + n - v.n), *this; }",
	  "    modnum &operator*=(modnum v) { return n = (u64(n) * v.n) % MOD, *this; }",
	  "    modnum &operator/=(modnum v) { return *this *= v.inv(); }",
	  "",
	  "    friend modnum operator+(modnum lhs, modnum rhs) { return lhs += rhs; }",
	  "    friend modnum operator-(modnum lhs, modnum rhs) { return lhs -= rhs; }",
	  "    friend modnum operator*(modnum lhs, modnum rhs) { return lhs *= rhs; }",
	  "    friend modnum operator/(modnum lhs, modnum rhs) { return lhs /= rhs; }",
	  "",
	  "    friend string to_string(modnum v) { return to_string(v.n); }",
	  "    friend bool operator==(modnum lhs, modnum rhs) { return lhs.n == rhs.n; }",
	  "    friend bool operator!=(modnum lhs, modnum rhs) { return lhs.n != rhs.n; }",
	  "    friend ostream &operator<<(ostream &out, modnum v) { return out << v.n; }",
	  "    friend istream &operator>>(istream &in, modnum &v) {",
	  "        i64 n;",
	  "        return in >> n, v = modnum(n), in;",
	  "    }",
	  "};"
	],
	"description": "!Change modnum::MOD!, Change size of integer"
  },
  "default 9 decimal places": {
	"prefix": "setprecision",
	"body": [
	  "cout << fixed << setprecision(16);"
	],
	"description": "default 9 decimal places"
  },
  "Increases Stack Size to 1GB, see https://codeforces.com/blog/entry/94726?#comment-839042": {
	"prefix": "increasememory",
	"body": [
	  "void main_() {",
	  "    int n;",
	  "    cin >> n;",
	  "    cout << n << '\\n';",
	  "}",
	  "static void run_with_stack_size(void (*func)(void), size_t stsize) {",
	  "    char *stack, *send;",
	  "    stack = (char *)malloc(stsize);",
	  "    send = stack + stsize - 16;",
	  "    send = (char *)((uintptr_t)send / 16 * 16);",
	  "    asm volatile(",
	  "        \"mov %%rsp, (%0)\\n\"",
	  "        \"mov %0, %%rsp\\n\"",
	  "        :",
	  "        : \"r\"(send));",
	  "    func();",
	  "    asm volatile(\"mov (%0), %%rsp\\n\" : : \"r\"(send));",
	  "    free(stack);",
	  "}",
	  "int main() {",
	  "    run_with_stack_size(main_, 1024 * 1024 * 1024);",
	  "    return 0;",
	  "}"
	],
	"description": "Increases Stack Size to 1GB, see https://codeforces.com/blog/entry/94726?#comment-839042"
  },
  "1-index, CHANGE": {
	"prefix": "array_segtree",
	"body": [
	  "//1-indexed",
	  "const int maxn = 2e5 + 100; //CHANGE",
	  "const int NON = 1e9; //CHANGE",
	  "int tree[4 * maxn+3]; //Long long? Default values?",
	  "",
	  "int comb(int a, int b){",
	  "    return min(a, b);",
	  "}",
	  "",
	  "//Resets value",
	  "void update(int idx, int val, int id=1, int tl=1, int tr=maxn) {",
	  "    if (tl > idx || tr < idx) return;",
	  "    if (tl == tr) {tree[id] = val; return;}",
	  "    update(idx, val, 2*id, tl, (tl+tr)/2);",
	  "    update(idx, val, 2*id+1, (tl+tr)/2+1, tr);",
	  "    tree[id] = comb(tree[2 * id], tree[2 * id + 1]);",
	  "}",
	  "",
	  "int query(int l, int r, int id=1, int tl=1, int tr=maxn) {",
	  "    if (l > tr || r < tl) return NON;",
	  "    if (l <= tl && tr <= r) return tree[id];",
	  "    return comb(query(l, r, 2*id, tl, (tl+tr)/2), ",
	  "    query(l, r, 2*id+1, (tl+tr)/2+1, tr));",
	  "}"
	],
	"description": "1-index, CHANGE"
  }
}